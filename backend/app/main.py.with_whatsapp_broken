from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from sqlalchemy import text
from pydantic import BaseModel
from typing import Optional
import httpx
import re

from .database import get_db, engine, Base
from .models import Tenant, Conversation, Message, PlanType, WhatsAppProvider
from .ai_prompts import build_chat_messages

AI_API_KEY = "sk-442c51d150d2471e87f3913a611737a2"
AI_URL = "https://api.deepseek.com/v1/chat/completions"

Base.metadata.create_all(bind=engine)

app = FastAPI(title="NéoBot MVP API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class TenantCreate(BaseModel):
    name: str
    email: str
    phone: str
    business_type: Optional[str] = "autre"

class MessageWebhook(BaseModel):
    tenant_id: int
    from_number: str
    message: str

async def generate_ai_response(tenant: Tenant, customer_message: str, conversation_history: list = None) -> str:
    simple = {
        r"^(salut|bonjour|bonsoir|hello|hi|hey)[\s!?]*$": f"Bonjour ! Bienvenue chez {tenant.name}. Comment puis-je vous aider ?",
        r"^(merci|thank you|thanks)[\s!?]*$": "Avec plaisir ! N'hésitez pas.",
        r"^(au revoir|bye|tchao)[\s!?]*$": f"Au revoir ! À bientôt chez {tenant.name}."
    }
    
    msg_lower = customer_message.lower().strip()
    for pattern, response in simple.items():
        if re.match(pattern, msg_lower, re.IGNORECASE):
            return response
    
    if len(customer_message.split()) <= 2:
        return f"Bonjour ! Pouvez-vous préciser votre demande pour {tenant.name} ?"
    
    try:
        messages = build_chat_messages(tenant, customer_message, conversation_history)
        
        async with httpx.AsyncClient(timeout=30.0) as client:
            print(f"🔍 Appel IA DeepSeek pour: {customer_message[:50]}...")
            response = await client.post(
                AI_URL,
                json={"model": "deepseek-chat", "messages": messages, "temperature": 0.7, "max_tokens": 150},
                headers={"Authorization": f"Bearer {AI_API_KEY}"}
            )
            
            print(f"📡 Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"💰 Tokens: {data['usage']['total_tokens']}")
                return data["choices"][0]["message"]["content"]
            elif response.status_code == 402:
                print("⚠️ Balance insuffisante DeepSeek")
                print("📢 NOTIFICATION: ⚠️ ALERTE: Crédit IA épuisé! Rechargez DeepSeek.")
                return f"Merci pour votre message. Un conseiller vous répondra sous peu."
            else:
                print(f"❌ Erreur: {response.text[:200]}")
                return f"Merci pour votre message. Un conseiller vous répondra sous peu."
                
    except Exception as e:
        print(f"🔥 ERREUR: {type(e).__name__}: {str(e)}")
        return f"Merci de nous contacter. Notre équipe vous répond rapidement."

@app.get("/")
def read_root():
    return {"message": "NéoBot MVP API", "status": "running", "version": "1.0.0"}

@app.get("/health")
def health_check(db: Session = Depends(get_db)):
    from datetime import datetime
    db.execute(text("SELECT 1"))
    return {"status": "healthy", "database": "connected", "timestamp": datetime.now().isoformat()}

@app.get("/api/ai/status")
async def check_ai_credits():
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.deepseek.com/user/balance",
                headers={"Authorization": f"Bearer {AI_API_KEY}"}
            )
            if response.status_code == 200:
                data = response.json()
                balance = data.get("balance_usd", 0)
                total = data.get("total_granted_usd", 0)
                return {
                    "status": "ok" if balance > 1 else "low",
                    "balance_usd": balance,
                    "total_granted": total,
                    "message": f"Balance: ${balance}" if balance > 1 else "⚠️ Balance faible: $" + str(balance)
                }
            return {"status": "error", "message": response.text}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/api/tenants")
def create_tenant(tenant: TenantCreate, db: Session = Depends(get_db)):
    existing = db.query(Tenant).filter(Tenant.email == tenant.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email déjà enregistré")
    
    db_tenant = Tenant(
        name=tenant.name,
        email=tenant.email,
        phone=tenant.phone,
        business_type=tenant.business_type,
        plan=PlanType.BASIQUE,
        whatsapp_provider=WhatsAppProvider.WASENDER_API
    )
    
    # Activer essai gratuit automatiquement
    db_tenant.activate_trial()
    
    db.add(db_tenant)
    db.commit()
    db.refresh(db_tenant)
    
    plan_config = db_tenant.get_plan_config()
    
    print(f"✅ Nouveau tenant: {db_tenant.name} ({db_tenant.email})")
    
    return {
        "id": db_tenant.id,
        "name": db_tenant.name,
        "email": db_tenant.email,
        "plan": db_tenant.plan.value,
        "trial_days": plan_config["trial_days"],
        "trial_ends_at": db_tenant.trial_ends_at.isoformat() if db_tenant.trial_ends_at else None,
        "messages_limit": plan_config["messages_limit"],
        "status": "created"
    }

@app.get("/api/tenants/{tenant_id}")
def get_tenant(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404, detail="Client non trouvé")
    
    plan_config = tenant.get_plan_config()
    
    return {
        "id": tenant.id,
        "name": tenant.name,
        "email": tenant.email,
        "phone": tenant.phone,
        "business_type": tenant.business_type,
        "plan": {
            "current": tenant.plan.value,
            "name": plan_config["name"],
            "price_fcfa": plan_config["price_fcfa"],
            "messages_limit": plan_config["messages_limit"],
            "features": plan_config["features"]
        },
        "usage": {
            "messages_used": tenant.messages_used,
            "messages_limit": tenant.messages_limit,
            "percentage": round((tenant.messages_used / tenant.messages_limit) * 100, 1) if tenant.messages_limit else 0
        },
        "trial": {
            "is_trial": tenant.is_trial,
            "ends_at": tenant.trial_ends_at.isoformat() if tenant.trial_ends_at else None,
            "days_remaining": tenant.days_remaining_trial(),
            "is_expired": tenant.is_trial_expired()
        },
        "whatsapp": {
            "provider": tenant.whatsapp_provider.value,
            "connected": tenant.whatsapp_connected
        }
    }

@app.post("/webhook/whatsapp")
async def whatsapp_webhook(data: MessageWebhook, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == data.tenant_id).first()
    if not tenant:
        return {"error": "Tenant non trouvé"}
    
    # Vérifier essai expiré
    if tenant.is_trial_expired():
        return {"error": "Essai gratuit expiré", "message": "Veuillez souscrire à un abonnement"}
    
    # Vérifier quota
    if tenant.messages_used >= tenant.messages_limit:
        return {"error": "Quota dépassé", "message": f"Limite de {tenant.messages_limit} messages atteinte"}
    
    conversation = db.query(Conversation).filter(
        Conversation.tenant_id == data.tenant_id,
        Conversation.customer_phone == data.from_number
    ).first()
    
    if not conversation:
        conversation = Conversation(
            tenant_id=data.tenant_id,
            customer_phone=data.from_number,
            status="active"
        )
        db.add(conversation)
        db.commit()
        db.refresh(conversation)
    
    incoming_msg = Message(
        conversation_id=conversation.id,
        content=data.message,
        direction="incoming",
        is_ai=False
    )
    db.add(incoming_msg)
    
    history = db.query(Message).filter(
        Message.conversation_id == conversation.id
    ).order_by(Message.created_at.desc()).limit(10).all()
    history.reverse()
    
    ai_response = await generate_ai_response(tenant, data.message, history)
    
    outgoing_msg = Message(
        conversation_id=conversation.id,
        content=ai_response,
        direction="outgoing",
        is_ai=True
    )
    db.add(outgoing_msg)
    
    tenant.messages_used += 1
    db.commit()
    
    print(f"📱 {data.from_number}: {data.message}")
    print(f"🤖 {tenant.business_type}: {ai_response}")
    
    return {"response": ai_response, "conversation_id": conversation.id}

@app.get("/api/plans")
def get_plans():
    plans = {}
    for plan_type in PlanType:
        tenant_temp = Tenant(plan=plan_type)
        config = tenant_temp.get_plan_config()
        plans[plan_type.value] = config
    return {"plans": plans}

@app.get("/api/tenants/{tenant_id}/whatsapp/status")
def get_whatsapp_status(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    return {"tenant_id": tenant_id, "provider": tenant.whatsapp_provider.value, "connected": tenant.whatsapp_connected}

@app.get("/api/tenants/{tenant_id}/analytics")
def get_analytics(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    
    total_convs = db.query(Conversation).filter(Conversation.tenant_id == tenant_id).count()
    total_msgs = db.query(Message).join(Conversation).filter(Conversation.tenant_id == tenant_id).count()
    ai_msgs = db.query(Message).join(Conversation).filter(Conversation.tenant_id == tenant_id, Message.is_ai == True).count()
    
    return {
        "tenant_id": tenant_id,
        "period": "all_time",
        "conversations": {"total": total_convs},
        "messages": {"total": total_msgs, "from_ai": ai_msgs, "from_customers": total_msgs - ai_msgs, "usage_this_month": tenant.messages_used, "limit": tenant.messages_limit},
        "plan": {"current": tenant.plan.value, "is_trial": tenant.is_trial},
        "trial": {"days_remaining": tenant.days_remaining_trial(), "is_expired": tenant.is_trial_expired()}
    }

@app.get("/api/tenants/{tenant_id}/conversations")
def get_conversations(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    
    convs = db.query(Conversation).filter(Conversation.tenant_id == tenant_id).order_by(Conversation.last_message_at.desc()).limit(50).all()
    result = []
    for c in convs:
        last_msg = db.query(Message).filter(Message.conversation_id == c.id).order_by(Message.created_at.desc()).first()
        result.append({
            "id": c.id,
            "customer_phone": c.customer_phone,
            "last_message": last_msg.content[:50] if last_msg else None,
            "created_at": c.created_at.isoformat()
        })
    return {"conversations": result}

from .whatsapp_client import WhatsAppClient
whatsapp = WhatsAppClient()

@app.post("/api/tenants/{tenant_id}/whatsapp/connect")
async def connect_whatsapp(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    result = await whatsapp.initiate_connection(tenant_id)
    if result.get("success"):
        return {"success": True, "qr_code": result["qr_code"]}
    raise HTTPException(status_code=500, detail=result.get("error"))

@app.post("/webhook/whatsapp/connected")
async def whatsapp_connected_webhook(data: dict, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == data["tenant_id"]).first()
    if tenant:
        tenant.whatsapp_connected = True
        db.commit()
    return {"status": "ok"}
