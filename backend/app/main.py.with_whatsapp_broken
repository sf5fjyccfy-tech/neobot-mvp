from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from sqlalchemy import text
from pydantic import BaseModel
from typing import Optional
import httpx
import re

from .database import get_db, engine, Base
from .models import Tenant, Conversation, Message, PlanType, WhatsAppProvider
from .ai_prompts import build_chat_messages

AI_API_KEY = "sk-442c51d150d2471e87f3913a611737a2"
AI_URL = "https://api.deepseek.com/v1/chat/completions"

Base.metadata.create_all(bind=engine)

app = FastAPI(title="NÃ©oBot MVP API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class TenantCreate(BaseModel):
    name: str
    email: str
    phone: str
    business_type: Optional[str] = "autre"

class MessageWebhook(BaseModel):
    tenant_id: int
    from_number: str
    message: str

async def generate_ai_response(tenant: Tenant, customer_message: str, conversation_history: list = None) -> str:
    simple = {
        r"^(salut|bonjour|bonsoir|hello|hi|hey)[\s!?]*$": f"Bonjour ! Bienvenue chez {tenant.name}. Comment puis-je vous aider ?",
        r"^(merci|thank you|thanks)[\s!?]*$": "Avec plaisir ! N'hÃ©sitez pas.",
        r"^(au revoir|bye|tchao)[\s!?]*$": f"Au revoir ! Ã€ bientÃ´t chez {tenant.name}."
    }
    
    msg_lower = customer_message.lower().strip()
    for pattern, response in simple.items():
        if re.match(pattern, msg_lower, re.IGNORECASE):
            return response
    
    if len(customer_message.split()) <= 2:
        return f"Bonjour ! Pouvez-vous prÃ©ciser votre demande pour {tenant.name} ?"
    
    try:
        messages = build_chat_messages(tenant, customer_message, conversation_history)
        
        async with httpx.AsyncClient(timeout=30.0) as client:
            print(f"ğŸ” Appel IA DeepSeek pour: {customer_message[:50]}...")
            response = await client.post(
                AI_URL,
                json={"model": "deepseek-chat", "messages": messages, "temperature": 0.7, "max_tokens": 150},
                headers={"Authorization": f"Bearer {AI_API_KEY}"}
            )
            
            print(f"ğŸ“¡ Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"ğŸ’° Tokens: {data['usage']['total_tokens']}")
                return data["choices"][0]["message"]["content"]
            elif response.status_code == 402:
                print("âš ï¸ Balance insuffisante DeepSeek")
                print("ğŸ“¢ NOTIFICATION: âš ï¸ ALERTE: CrÃ©dit IA Ã©puisÃ©! Rechargez DeepSeek.")
                return f"Merci pour votre message. Un conseiller vous rÃ©pondra sous peu."
            else:
                print(f"âŒ Erreur: {response.text[:200]}")
                return f"Merci pour votre message. Un conseiller vous rÃ©pondra sous peu."
                
    except Exception as e:
        print(f"ğŸ”¥ ERREUR: {type(e).__name__}: {str(e)}")
        return f"Merci de nous contacter. Notre Ã©quipe vous rÃ©pond rapidement."

@app.get("/")
def read_root():
    return {"message": "NÃ©oBot MVP API", "status": "running", "version": "1.0.0"}

@app.get("/health")
def health_check(db: Session = Depends(get_db)):
    from datetime import datetime
    db.execute(text("SELECT 1"))
    return {"status": "healthy", "database": "connected", "timestamp": datetime.now().isoformat()}

@app.get("/api/ai/status")
async def check_ai_credits():
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.deepseek.com/user/balance",
                headers={"Authorization": f"Bearer {AI_API_KEY}"}
            )
            if response.status_code == 200:
                data = response.json()
                balance = data.get("balance_usd", 0)
                total = data.get("total_granted_usd", 0)
                return {
                    "status": "ok" if balance > 1 else "low",
                    "balance_usd": balance,
                    "total_granted": total,
                    "message": f"Balance: ${balance}" if balance > 1 else "âš ï¸ Balance faible: $" + str(balance)
                }
            return {"status": "error", "message": response.text}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/api/tenants")
def create_tenant(tenant: TenantCreate, db: Session = Depends(get_db)):
    existing = db.query(Tenant).filter(Tenant.email == tenant.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email dÃ©jÃ  enregistrÃ©")
    
    db_tenant = Tenant(
        name=tenant.name,
        email=tenant.email,
        phone=tenant.phone,
        business_type=tenant.business_type,
        plan=PlanType.BASIQUE,
        whatsapp_provider=WhatsAppProvider.WASENDER_API
    )
    
    # Activer essai gratuit automatiquement
    db_tenant.activate_trial()
    
    db.add(db_tenant)
    db.commit()
    db.refresh(db_tenant)
    
    plan_config = db_tenant.get_plan_config()
    
    print(f"âœ… Nouveau tenant: {db_tenant.name} ({db_tenant.email})")
    
    return {
        "id": db_tenant.id,
        "name": db_tenant.name,
        "email": db_tenant.email,
        "plan": db_tenant.plan.value,
        "trial_days": plan_config["trial_days"],
        "trial_ends_at": db_tenant.trial_ends_at.isoformat() if db_tenant.trial_ends_at else None,
        "messages_limit": plan_config["messages_limit"],
        "status": "created"
    }

@app.get("/api/tenants/{tenant_id}")
def get_tenant(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404, detail="Client non trouvÃ©")
    
    plan_config = tenant.get_plan_config()
    
    return {
        "id": tenant.id,
        "name": tenant.name,
        "email": tenant.email,
        "phone": tenant.phone,
        "business_type": tenant.business_type,
        "plan": {
            "current": tenant.plan.value,
            "name": plan_config["name"],
            "price_fcfa": plan_config["price_fcfa"],
            "messages_limit": plan_config["messages_limit"],
            "features": plan_config["features"]
        },
        "usage": {
            "messages_used": tenant.messages_used,
            "messages_limit": tenant.messages_limit,
            "percentage": round((tenant.messages_used / tenant.messages_limit) * 100, 1) if tenant.messages_limit else 0
        },
        "trial": {
            "is_trial": tenant.is_trial,
            "ends_at": tenant.trial_ends_at.isoformat() if tenant.trial_ends_at else None,
            "days_remaining": tenant.days_remaining_trial(),
            "is_expired": tenant.is_trial_expired()
        },
        "whatsapp": {
            "provider": tenant.whatsapp_provider.value,
            "connected": tenant.whatsapp_connected
        }
    }

@app.post("/webhook/whatsapp")
async def whatsapp_webhook(data: MessageWebhook, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == data.tenant_id).first()
    if not tenant:
        return {"error": "Tenant non trouvÃ©"}
    
    # VÃ©rifier essai expirÃ©
    if tenant.is_trial_expired():
        return {"error": "Essai gratuit expirÃ©", "message": "Veuillez souscrire Ã  un abonnement"}
    
    # VÃ©rifier quota
    if tenant.messages_used >= tenant.messages_limit:
        return {"error": "Quota dÃ©passÃ©", "message": f"Limite de {tenant.messages_limit} messages atteinte"}
    
    conversation = db.query(Conversation).filter(
        Conversation.tenant_id == data.tenant_id,
        Conversation.customer_phone == data.from_number
    ).first()
    
    if not conversation:
        conversation = Conversation(
            tenant_id=data.tenant_id,
            customer_phone=data.from_number,
            status="active"
        )
        db.add(conversation)
        db.commit()
        db.refresh(conversation)
    
    incoming_msg = Message(
        conversation_id=conversation.id,
        content=data.message,
        direction="incoming",
        is_ai=False
    )
    db.add(incoming_msg)
    
    history = db.query(Message).filter(
        Message.conversation_id == conversation.id
    ).order_by(Message.created_at.desc()).limit(10).all()
    history.reverse()
    
    ai_response = await generate_ai_response(tenant, data.message, history)
    
    outgoing_msg = Message(
        conversation_id=conversation.id,
        content=ai_response,
        direction="outgoing",
        is_ai=True
    )
    db.add(outgoing_msg)
    
    tenant.messages_used += 1
    db.commit()
    
    print(f"ğŸ“± {data.from_number}: {data.message}")
    print(f"ğŸ¤– {tenant.business_type}: {ai_response}")
    
    return {"response": ai_response, "conversation_id": conversation.id}

@app.get("/api/plans")
def get_plans():
    plans = {}
    for plan_type in PlanType:
        tenant_temp = Tenant(plan=plan_type)
        config = tenant_temp.get_plan_config()
        plans[plan_type.value] = config
    return {"plans": plans}

@app.get("/api/tenants/{tenant_id}/whatsapp/status")
def get_whatsapp_status(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    return {"tenant_id": tenant_id, "provider": tenant.whatsapp_provider.value, "connected": tenant.whatsapp_connected}

@app.get("/api/tenants/{tenant_id}/analytics")
def get_analytics(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    
    total_convs = db.query(Conversation).filter(Conversation.tenant_id == tenant_id).count()
    total_msgs = db.query(Message).join(Conversation).filter(Conversation.tenant_id == tenant_id).count()
    ai_msgs = db.query(Message).join(Conversation).filter(Conversation.tenant_id == tenant_id, Message.is_ai == True).count()
    
    return {
        "tenant_id": tenant_id,
        "period": "all_time",
        "conversations": {"total": total_convs},
        "messages": {"total": total_msgs, "from_ai": ai_msgs, "from_customers": total_msgs - ai_msgs, "usage_this_month": tenant.messages_used, "limit": tenant.messages_limit},
        "plan": {"current": tenant.plan.value, "is_trial": tenant.is_trial},
        "trial": {"days_remaining": tenant.days_remaining_trial(), "is_expired": tenant.is_trial_expired()}
    }

@app.get("/api/tenants/{tenant_id}/conversations")
def get_conversations(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    
    convs = db.query(Conversation).filter(Conversation.tenant_id == tenant_id).order_by(Conversation.last_message_at.desc()).limit(50).all()
    result = []
    for c in convs:
        last_msg = db.query(Message).filter(Message.conversation_id == c.id).order_by(Message.created_at.desc()).first()
        result.append({
            "id": c.id,
            "customer_phone": c.customer_phone,
            "last_message": last_msg.content[:50] if last_msg else None,
            "created_at": c.created_at.isoformat()
        })
    return {"conversations": result}

from .whatsapp_client import WhatsAppClient
whatsapp = WhatsAppClient()

@app.post("/api/tenants/{tenant_id}/whatsapp/connect")
async def connect_whatsapp(tenant_id: int, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
    if not tenant:
        raise HTTPException(status_code=404)
    result = await whatsapp.initiate_connection(tenant_id)
    if result.get("success"):
        return {"success": True, "qr_code": result["qr_code"]}
    raise HTTPException(status_code=500, detail=result.get("error"))

@app.post("/webhook/whatsapp/connected")
async def whatsapp_connected_webhook(data: dict, db: Session = Depends(get_db)):
    tenant = db.query(Tenant).filter(Tenant.id == data["tenant_id"]).first()
    if tenant:
        tenant.whatsapp_connected = True
        db.commit()
    return {"status": "ok"}
